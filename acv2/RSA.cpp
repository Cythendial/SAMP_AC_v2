#include "RSA.h"
#include "../Shared/crypto++/rsa.h"
#include "../Shared/crypto++/integer.h"
#include "../Shared/crypto++/osrng.h"
#include <boost\lexical_cast.hpp>

using namespace CryptoPP;

std::string Encrypt(unsigned char* c)
{
	CryptoPP::Integer n("0x154297226916254268865230019057196424160847776244752836691325963692648698749455081697553827419468173279804250923773820118947389161328871855664943573134745118984054275237418590284616794481757116751161505065441458875365466487716774974023322967349288310147562013060768871425928058596712177155371352092308846281477.");
	CryptoPP::Integer e("0x17.");
	//CryptoPP::Integer d("0x58995998526803102801411477874810397473265326211229025793742280235424502463026943002005875189796654489336919470854695927832825267566921591871890189727990771261535572506635098817876037764865239853746161803578997771024381868318265496659864792511550244677198553264436228929769518198857854813708037643631355931855.");

	CryptoPP::RSA::PublicKey pubKey;
	pubKey.Initialize(n, e);

	CryptoPP::Integer m((const byte *)c, strlen((const char*)c));

	return boost::lexical_cast<std::string>(pubKey.ApplyFunction(m));
}

std::string Decrypt(unsigned char* s)
{
	CryptoPP::Integer n("0x154297226916254268865230019057196424160847776244752836691325963692648698749455081697553827419468173279804250923773820118947389161328871855664943573134745118984054275237418590284616794481757116751161505065441458875365466487716774974023322967349288310147562013060768871425928058596712177155371352092308846281477.");
	CryptoPP::Integer e("0x17.");
	CryptoPP::Integer d("0x58995998526803102801411477874810397473265326211229025793742280235424502463026943002005875189796654489336919470854695927832825267566921591871890189727990771261535572506635098817876037764865239853746161803578997771024381868318265496659864792511550244677198553264436228929769518198857854813708037643631355931855.");

	CryptoPP::RSA::PrivateKey privKey;
	privKey.Initialize(n, e, d);

	AutoSeededRandomPool prng;

	CryptoPP::Integer i((const char*)s);

	Integer r = privKey.CalculateInverse(prng, i);

	std::string recovered;
	recovered.resize(r.MinEncodedSize());

	r.Encode((byte *)recovered.data(), recovered.size());
	return recovered;
}